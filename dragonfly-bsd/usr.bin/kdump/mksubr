#!/bin/sh
#
# Generates kdump_subr.c
# mkioctls is a special-purpose script, and works fine as it is
# now, so it remains independent. The idea behind how it generates
# its list was heavily borrowed here.
#
# Some functions here are automatically generated. This can mean
# the user will see unusual kdump output or errors while building
# if the underlying .h files are changed significantly.
#
# Key:
# AUTO: Completely auto-generated with either the "or" or the "switch"
# method.
# AUTO - Special: Generated automatically, but with some extra commands
# that the auto_*_type() functions are inappropriate for.
# MANUAL: Manually entered and must therefore be manually updated.

# $FreeBSD: src/usr.bin/kdump/mksubr,v 1.9 2007/04/09 19:16:24 emaste Exp $

set -e

LC_ALL=C; export LC_ALL

if [ -z "$1" ]
then
	echo "usage: sh $0 include-dir"
	exit 1
fi
include_dir=$1

#
# Automatically generates a C function that will print out the
# numeric input as a pipe-delimited string of the appropriate
# #define keys. ex:
# S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH
# The XOR is necessary to prevent including the "0"-value in every
# line.
#
auto_or_int () {
	local name grep file
	name=$1
	grep=$2
	file=$3

	cat <<_EOF_
/* AUTO */
void
$name (int arg)
{
	bool	or = false;
	printf("%#x<", arg);
_EOF_
	egrep "^#[[:space:]]*define[[:space:]]+"${grep}"[[:space:]]*" \
		$include_dir/$file | \
	awk '{ for (i = 1; i <= NF; i++) \
		if ($i ~ /define/) \
			break; \
		++i; \
		printf "\tif(!((arg>0)^((%s)>0)))\n\t\tif_print_or(arg, %s, or);\n", $i, $i }'
cat <<_EOF_
	printf(">");
	if (or == false)
		printf("<invalid>%d", arg);
}

_EOF_
}

#
# Automatically generates a C function that will print out the
# numeric input as a pipe-delimited string of the appropriate
# #define keys. ex:
# S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH
# The XOR is necessary to prevent including the "0"-value in every
# line.
#
auto_or_long () {
	local name grep file
	name=$1
	grep=$2
	file=$3

	cat <<_EOF_
/* AUTO */
void
$name (long arg)
{
	bool	or = false;
	printf("%#lx<", arg);
_EOF_
	egrep "^#[[:space:]]*define[[:space:]]+"${grep}"[[:space:]]*" \
		$include_dir/$file | \
	awk '{ for (i = 1; i <= NF; i++) \
		if ($i ~ /define/) \
			break; \
		++i; \
		printf "\tif(!((arg>0)^((%s)>0)))\n\t\tif_print_or(arg, %s, or);\n", $i, $i }'
cat <<_EOF_
	printf(">");
	if (or == false)
		printf("<invalid>%ld", arg);
}

_EOF_
}

#
# Automatically generates a C function used when the argument
# maps to a single, specific #definition
#
auto_switch_type () {
	local name grep file noinvdef
	name=$1
	grep=$2
	file=$3
	noinvdef=$4

	cat <<_EOF_
/* AUTO */
void
$name (int arg)
{
	switch (arg) {
_EOF_
	egrep "^#[[:space:]]*define[[:space:]]+"${grep}"[[:space:]]*" \
		$include_dir/$file | \
	awk '{ for (i = 1; i <= NF; i++) \
		if ($i ~ /define/) \
			break; \
		++i; \
		printf "\tcase %s:\n\t\tprintf(\"%s\");\n\t\tbreak;\n", $i, $i }'
	if [ -z "$noinvdef" ]; then
cat <<_EOF_
	default: /* Should not reach */
		printf("<invalid=%ld>", (long)arg);
	}
}

_EOF_
	else
cat <<_EOF_
	default:
		printf("%ld", (long)arg);
	}
}

_EOF_
	fi
}

#
# Automatically generates a C function used when the argument
# maps to a #definition
#
auto_if_type () {
	local name grep file
	name=$1
	grep=$2
	file=$3

	cat <<_EOF_
/* AUTO */
void
$name (int arg)
{
_EOF_
	egrep "^#[[:space:]]*define[[:space:]]+"${grep}"[[:space:]]*" \
		$include_dir/$file | \
	awk '{ printf "\t"; \
		if (NR > 1) \
			printf "else " ; \
		printf "if (arg == %s) \n\t\tprintf(\"%s\");\n", $2, $2 }'
cat <<_EOF_
	else /* Should not reach */
		printf("<invalid=%ld>", (long)arg);
}

_EOF_
}

# C start

cat <<_EOF_
#define _KERNEL_STRUCTURES

#include <stdio.h>
#include <time.h>
#include <sys/fcntl.h>
#include <sys/stat.h>
#include <sys/unistd.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/param.h>
#include <sys/mount.h>
#include <sys/resource.h>
#include <sys/reboot.h>
#include <sched.h>
#include <sys/usched.h>
#include <sys/linker.h>
#include <sys/extattr.h>
#include <sys/acl.h>
#include <aio.h>
#include <sys/sem.h>
#include <sys/ipc.h>
#include <sys/rtprio.h>
#include <sys/shm.h>
#include <vfs/ufs/quota.h>
#include <sys/kenv.h>
#include <sys/checkpoint.h>
#include <sys/procctl.h>
#include <sys/mountctl.h>
#include <sys/varsym.h>

#include "kdump_subr.h"

/*
 * These are simple support macros. print_or utilizes a variable
 * defined in the calling function to track whether or not it should
 * print a logical-OR character ('|') before a string. if_print_or
 * simply handles the necessary "if" statement used in many lines
 * of this file.
 */
#define print_or(str,orflag) do {                  \\
	if (orflag) putchar('|'); else orflag = true; \\
	printf (str); }                            \\
	while (0)
#define if_print_or(i,flag,orflag) do {            \\
	if ((i & flag) == flag)                    \\
	print_or(#flag,orflag); }                  \\
	while (0)

/* MANUAL */
extern char *signames[]; /* from kdump.c */
void
signame (int sig)
{
	if (sig > 0 && sig < NSIG && signames[sig] != NULL)
		printf("SIG%s",signames[sig]);
	else
		printf("SIG %d", sig);
}

/* MANUAL */
void
semctlname (int cmd)
{
	switch (cmd) {
	case GETNCNT:
		printf("GETNCNT");
		break;
	case GETPID:
		printf("GETPID");
		break;
	case GETVAL:
		printf("GETVAL");
		break;
	case GETALL:
		printf("GETALL");
		break;
	case GETZCNT:
		printf("GETZCNT");
		break;
	case SETVAL:
		printf("SETVAL");
		break;
	case SETALL:
		printf("SETALL");
		break;
	case IPC_RMID:
		printf("IPC_RMID");
		break;
	case IPC_SET:
		printf("IPC_SET");
		break;
	case IPC_STAT:
		printf("IPC_STAT");
		break;
	default: /* Should not reach */
		printf("<invalid=%ld>", (long)cmd);
	}
}

/* MANUAL */
void
shmctlname (int cmd) {
	switch (cmd) {
	case IPC_RMID:
		printf("IPC_RMID");
		break;
	case IPC_SET:
		printf("IPC_SET");
		break;
	case IPC_STAT:
		printf("IPC_STAT");
		break;
	default: /* Should not reach */
		printf("<invalid=%ld>", (long)cmd);
	}
}

/* MANUAL */
void
semgetname (int flag) {
	int	or = 0;
	if_print_or(flag, SEM_R, or);
	if_print_or(flag, SEM_A, or);
	if_print_or(flag, (SEM_R>>3), or);
	if_print_or(flag, (SEM_A>>3), or);
	if_print_or(flag, (SEM_R>>6), or);
	if_print_or(flag, (SEM_A>>6), or);
}

/*
 * MANUAL
 *
 * Only used by SYS_open. Unless O_CREAT is set in flags, the
 * mode argument is unused (and often bogus and misleading).
 */
void
flagsandmodename (int flags, int mode, int decimal) {
	flagsname (flags);
	putchar(',');
	if ((flags & O_CREAT) == O_CREAT) {
		modename (mode);
	} else {
		if (decimal) {
			printf("<unused>%ld", (long)mode);
		} else {
			printf("<unused>%#lx", (long)mode);
		}
	}
}

/*
 * MANUAL
 *
 * [g|s]etsockopt's level argument can either be SOL_SOCKET or a value
 * referring to a line in /etc/protocols . It might be appropriate
 * to use getprotoent(3) here.
 */
void
sockoptlevelname (int level, int decimal)
{
	if (level == SOL_SOCKET) {
		printf("SOL_SOCKET");
	} else {
		if (decimal) {
			printf("%ld", (long)level);
		} else {
			printf("%#lx", (long)level);
		}
	}
}

_EOF_

auto_or_int "modename" "S_[A-Z]+[[:space:]]+[0-6]{7}" "sys/stat.h"
auto_or_int "flagsname" "O_[A-Z]+[[:space:]]+0x[0-9A-Fa-f]+" "sys/fcntl.h"
auto_or_int "accessmodename" "[A-Z]_OK[[:space:]]+0?x?[0-9A-Fa-f]+" "sys/unistd.h"
auto_or_int "mmapprotname" "PROT_[A-Z]+[[:space:]]+0x[0-9A-Fa-f]+" "sys/mman.h"
auto_or_int "mmapflagsname" "MAP_[A-Z]+[[:space:]]+0x[0-9A-Fa-f]+" "sys/mman.h"
auto_or_int "wait4optname" "W[A-Z]+[[:space:]]+[0-9]+" "sys/wait.h"
auto_or_int "getfsstatflagsname" "MNT_[A-Z]+[[:space:]]+0x[0-9][0-9][0-9][0-9][^0-9]" "sys/mount.h"
auto_or_int "mountflagsname" "MNT_[A-Z]+[[:space:]]+0x[0-9][0-9][0-9][0-9][0-9]+" "sys/mount.h"
auto_or_int "rebootoptname" "RB_[A-Z]+[[:space:]]+0x[0-9]+" "sys/reboot.h"
auto_or_int "flockname" "LOCK_[A-Z]+[[:space:]]+0x[0-9]+" "sys/fcntl.h"
auto_or_int "mlockallname" "MCL_[A-Z]+[[:space:]]+0x[0-9]+" "sys/mman.h"
auto_or_int "shmatname" "SHM_[A-Z]+[[:space:]]+[0-9]{6}+" "sys/shm.h"
auto_or_int "rforkname" "RF[A-Z]+[[:space:]]+\([0-9]+<<[0-9]+\)" "sys/unistd.h"
auto_or_long "chflagsname" "[SU]F_[A-Z]+[[:space:]]+0x[0-9]+" "sys/stat.h"
auto_or_int "atflagsname" "AT_[A-Z_]+[[:space:]]+[1-9]+[0-9]*" "sys/fcntl.h"

auto_switch_type "whencename" "SEEK_[A-Z]+[[:space:]]+[0-9]+" "sys/unistd.h"
auto_switch_type "rlimitname" "RLIMIT_[A-Z]+[[:space:]]+[0-9]+" "sys/resource.h"
auto_switch_type "shutdownhowname" "SHUT_[A-Z]+[[:space:]]+[0-9]+" "sys/socket.h"
auto_switch_type "prioname" "PRIO_[A-Z]+[[:space:]]+[0-9]" "sys/resource.h"
auto_switch_type "madvisebehavname" "_?MADV_[A-Z]+[[:space:]]+[0-9]+" "sys/mman.h"
auto_switch_type "msyncflagsname" "MS_[A-Z]+[[:space:]]+0x[0-9]+" "sys/mman.h"
auto_switch_type "schedpolicyname" "SCHED_[A-Z]+[[:space:]]+[0-9]+" "sched.h"
auto_switch_type "extattrctlname" "EXTATTR_NAMESPACE_[A-Z]+[[:space:]]+0x[0-9]+" "sys/extattr.h"
auto_switch_type "kldsymcmdname" "KLDSYM_[A-Z]+[[:space:]]+[0-9]+" "sys/linker.h"
auto_switch_type "sendfileflagsname" "SF_[A-Z]+[[:space:]]+[0-9]+" "sys/socket.h"
auto_switch_type "acltypename" "ACL_TYPE_[A-Z]+[[:space:]]+0x[0-9]+" "sys/acl.h"
auto_switch_type "sigprocmaskhowname" "SIG_[A-Z]+[[:space:]]+[0-9]+" "sys/signal.h"
auto_switch_type "lio_listioname" "LIO_(NO)?WAIT[[:space:]]+[0-9]+" "aio.h"
auto_switch_type "minheritname" "INHERIT_[A-Z]+[[:space:]]+[0-9]+" "sys/mman.h"
auto_switch_type "quotactlname" "Q_[A-Z]+[[:space:]]+0x[0-9]+" "vfs/ufs/quota.h"
auto_if_type "sockdomainname" "PF_[[:alnum:]]+[[:space:]]+" "sys/socket.h"
auto_if_type "sockipprotoname" "IPPROTO_[[:alnum:]]+[[:space:]]+" "netinet/in.h"
auto_switch_type "sockoptname" "SO_[A-Z]+[[:space:]]+0x[0-9]+" "sys/socket.h"
auto_switch_type "socktypename" "SOCK_[A-Z]+[[:space:]]+[1-9]+[0-9]*" "sys/socket.h"
auto_switch_type "clockidname" "CLOCK_[[:alnum:]]+" "time.h" "noinvdef"
auto_switch_type "pathconfname" "_PC_[[:alnum:]]+" "sys/unistd.h"
auto_switch_type "uschedcmdname" "USCHED_[[:alnum:]]+" "sys/usched.h"
auto_switch_type "ckpttypename" "CKPT_[[:alnum:]]+" "sys/checkpoint.h"
auto_switch_type "procctlcmdname" "PROC_[[:alnum:]]+" "sys/procctl.h"
auto_switch_type "mountctlopname" "MOUNTCTL_[[:alnum:]]+" "sys/mountctl.h"
auto_switch_type "varsymlvlname" "VARSYM_[A-Z]+[[:space:]]+[1-9]+[0-9]*" "sys/varsym.h"

cat <<_EOF_
/*
 * AUTO - Special
 * F_ is used to specify fcntl commands as well as arguments. Both sets are
 * grouped in fcntl.h, and this awk script grabs the first group.
 */
void
fcntlcmdname (int cmd, int arg, int decimal)
{
	switch (cmd) {
_EOF_
egrep "^#[[:space:]]*define[[:space:]]+F_[A-Z0-9_]+[[:space:]]+[0-9]+[[:space:]]*" \
	$include_dir/sys/fcntl.h | \
	awk 'BEGIN { o=0 } { for (i = 1; i <= NF; i++) \
		if ($i ~ /define/) \
			break; \
		++i; \
		if (o <= $(i+1)) \
			printf "\tcase %s:\n\t\tprintf(\"%s\");\n\t\tbreak;\n", $i, $i; \
		else \
			exit; \
		o = $(i+1) }'
cat <<_EOF_
	default: /* Should not reach */
		printf("<invalid=%ld>", (long)cmd);
	}
	putchar(',');
	if (cmd == F_GETFD || cmd == F_SETFD) {
		if (arg == FD_CLOEXEC)
			printf("FD_CLOEXEC");
		else if (arg == 0)
			printf("0");
		else {
			if (decimal)
				printf("<invalid>%ld", (long)arg);
			else
				printf("<invalid>%#lx", (long)arg);
		}
	} else if (cmd == F_SETFL) {
		flagsname(arg);
	} else {
		if (decimal)
			printf("%ld", (long)arg);
		else
			printf("%#lx", (long)arg);
	}
}

/*
 * AUTO - Special
 *
 * The only reason this is not fully automated is due to the
 * grep -v RTP_PRIO statement. A better egrep line should
 * make this capable of being a auto_switch_type() function.
 */
void
rtprioname (int func)
{
	switch (func) {
_EOF_
egrep "^#[[:space:]]*define[[:space:]]+RTP_[A-Z]+[[:space:]]+0x[0-9]+[[:space:]]*" \
	$include_dir/sys/rtprio.h | grep -v RTP_PRIO | \
	awk '{ for (i = 1; i <= NF; i++) \
		if ($i ~ /define/) \
			break; \
		++i; \
		printf "\tcase %s:\n\t\tprintf(\"%s\");\n\t\tbreak;\n", $i, $i }'
cat <<_EOF_
	default: /* Should not reach */
		printf("<invalid=%ld>", (long)func);
	}
}

/*
 * AUTO - Special
 *
 * The send and recv functions have a flags argument which can be
 * set to 0. There is no corresponding #define. The auto_ functions
 * detect this as "invalid", which is incorrect here.
 */
void
sendrecvflagsname (int flags)
{
	int	or = 0;

	if (flags == 0) {
		printf("0");
		return;
	}

	printf("%#x<", flags);
_EOF_
egrep "^#[[:space:]]*define[[:space:]]+MSG_[A-Z_]+[[:space:]]+0x[0-9]+[[:space:]]*" $include_dir/sys/socket.h | \
	awk '{ for (i = 1; i <= NF; i++) \
		if ($i ~ /define/) \
			break; \
		++i; \
		printf "\tif(!((flags>0)^((%s)>0)))\n\t\tif_print_or(flags, %s, or);\n", $i, $i }'
cat <<_EOF_
	printf(">");
}

/*
 * AUTO - Special
 *
 * The only reason this is not fully automated is due to the
 * grep -vw ... statement. A better egrep line should
 * make this capable of being a auto_switch_type() function.
 */
void
kenvactname (int act)
{
	switch (act) {
_EOF_
egrep "^#[[:space:]]*define[[:space:]]+KENV_[A-Z]+[[:space:]]+[0-9]+[[:space:]]*" \
	$include_dir/sys/kenv.h | grep -vw -e KENV_MNAMELEN -e KENV_MVALLEN | \
	awk '{ for (i = 1; i <= NF; i++) \
		if ($i ~ /define/) \
			break; \
		++i; \
		printf "\tcase %s:\n\t\tprintf(\"%s\");\n\t\tbreak;\n", $i, $i }'
cat <<_EOF_
	default: /* Should not reach */
		printf("<invalid=%ld>", (long)act);
	}
}
_EOF_
